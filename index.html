<!DOCTYPE html>
  <head>
    <meta charset="utf-8">
    <title></title>
    <link rel="stylesheet" type="text/css" href="style.css">
  </head>
  <body>
  	<div class="filters" style="position:relative">
  		<label for="time">Time</label>
		<input style="width: 300px;" type="range" id="time" min="0" value="0" max="1439" step="1"><br>
		<input class="filter_button" name="dayChoice" id="z" value=0 type="radio" checked="checked">June 4, 2016 (Rainy Saturday)</input><br>
		<input class="filter_button" name="dayChoice" id="o" value=1 type="radio">June 8, 2016 (Rainy Wednesday)</input><br>
		<input class='filter_button' name="dayChoice" id='t' value=2 type='radio'>June 15, 2016 (Sunny Wednesday)</input><br>
		<input class="filter_button" name="dayChoice" id="th" value=3 type="radio">June 18, 2016 (Sunny Saturday)</input><br>


	</div>
	<p id="p">
	</p>
	<script src="https://d3js.org/d3.v4.min.js"></script>
	<script src="http://d3js.org/topojson.v2.min.js"></script>
	<script src="https://d3js.org/d3-geo.v1.min.js"></script>
	<script src="https://d3js.org/d3-geo-projection.v1.min.js"></script>


    <script>
	
	
   	var timeDict = {};
	var weatherDict = {};
	var weatherTimes = [];	
	
	var parseTaxi = function(row){
		
	    dropLong = parseFloat(row.dropoff_longitude);
	    dropLat = parseFloat(row.dropoff_latitude);
	    dropTime = row.dropoff_datetime;
	    dt = new Date(dropTime);
	    pickLong = parseFloat(row.pickup_longitude);
	    pickLat = parseFloat(row.pickup_latitude);
	    pickTime = row.pickup_datetime;
	    pt = new Date(pickTime);
	    fare = parseFloat(row.payment_amount);
	    dist = parseFloat(row.trip_distance);
	    //console.log(new Date(dropTime));
	  
	  var obj = { dropLong: dropLong, dropLat: dropLat, dropTime: dropTime, dt:dt, pickLong: pickLong, pickLat: pickLat, pickTime: pickTime, pt:pt, fare: fare, dist: dist};
      


	  var time = pickTime.split(' ')[1];
	  var slots =  time.split(':');
	  var tot = parseInt(slots[0])*60 + parseInt(slots[1]);
	  
	  if (!(tot in timeDict)){
		  timeDict[tot] = [obj];
	  }else {
		  timeDict[tot].push(obj);
	  }
	};
	
	var parseWeather = function(row){
        wt = new Date(row.Time);
        temp = parseFloat(row.Temp);
        events = row.Events;
        cond = row.Conditions;
        

        var obj = { wt: wt, temp: temp, events: events, cond: cond };

   
	  	var tot = wt.getHours()*60 + wt.getMinutes();

	  	if (!(tot in weatherTimes)){
			weatherTimes.push(tot);
	  	}
	  
	  	if (!(tot in weatherDict)){
			weatherDict[tot] = [obj];
	  	}else {
		  	weatherDict[tot].push(obj);
	  	}

	};

		
      
	  d3.queue()
	  .defer(d3.json, "nyc.json")
	  .defer(d3.csv, "June4Taxi.csv", parseTaxi)
	  .defer(d3.csv, "June8Taxi.csv", parseTaxi)
	  .defer(d3.csv, "June15Taxi.csv", parseTaxi)
	  .defer(d3.csv, "June18Taxi.csv", parseTaxi)
	  .defer(d3.csv, "Weather.csv", parseWeather)
	  .await(function (error, nyc, taxi4, taxi8, taxi15, taxi18, weather ) {
	    console.log("Code in the call-back function is only executed when every data file loads.");

	    console.log(error);
	    console.log(weatherTimes);

		var svg = d3.select("#p").append("svg").attr("height",1100).attr("width",500);
		
		var projection = d3.geoMercator().center([-73.94, 40.70])
				.scale(200000);
	    
		projection.fitExtent([[0,0], [svg.attr("width"), svg.attr("height")]], nyc);
				
		var pathGenerator = d3.geoPath().projection(projection);
		var p = svg.append("g");
		
		p.selectAll(".state")
		.data(nyc.features)
		.enter().append("path")
		.attr("d", pathGenerator)
		.attr("transform", "translate(-200,200) rotate(-27)")
		.attr("fill","grey");


		//Tooltip element for hover feature

		var tooltip = d3.select("body")
			.append("div")
			.attr("id", "tooltip")
			.style("position", "absolute")
			.style("z-index", "10")
			.style("visibility", "hidden")
			.text("");


		var timeAndDateText=d3.select("#p")
		.append("div")
		.attr("id", "daytime")
		.text("");

		svg.append("text")
		.attr("id", "dateAndTime1")
		.attr("x", 310)
		.attr("y", 100)
		.style("font-size", "14pt")
		.text("Use the Slider!");

		svg.append("text")
		.attr("id", "dateAndTime2")
		.attr("x", 310)
		.attr("y", 120)
		.style("font-size", "14pt")
		.text("");

		svg.append("text")
		.attr("id", "dateAndTime3")
		.attr("x", 310)
		.attr("y", 140)
		.style("font-size", "14pt")
		.text("");

		svg.append("svg:image")
		.attr("id", "weatherImage")
     	.attr('x',100)
     	.attr('y',100)
     	.attr('width', 100)
     	.attr('height', 100)
     	.attr("xlink:href", "clear.svg");
		
		var slide = d3.select("#time");
		slide.on("input", function(){
			t = this.value;
			dropDots(t, getCheckedButton("filter_button")[0]);

		});

		var check1 = d3.select("#z");
		check1.on("change", function(){
			dropDots(t, getCheckedButton("filter_button")[0]);
		});
		
		var check2 = d3.select("#o");
		check2.on("change", function(){
			dropDots(t, getCheckedButton("filter_button")[0]);
		});
		var check3 = d3.select("#t");
		check3.on("change", function(){
			dropDots(t, getCheckedButton("filter_button")[0]);
		});
		
		var check4 = d3.select("#th");
		check4.on("change", function(){
			dropDots(t, getCheckedButton("filter_button")[0]);
		});

		function dropDots(t, day){
			var data = timeDict[t]; 
			var weatherData = weatherDict[t];

			var u = closest(t, weatherTimes);
			console.log(u);

			if (day == 0){
				data = timeDict[t].filter(function(d){return d.pt.getDate()==4});
				weatherData = weatherDict[u].filter(function(d){return d.wt.getDate()==4});
			}
			else if (day == 1){
				data = timeDict[t].filter(function(d){return d.pt.getDate()==8});
				weatherData = weatherDict[u].filter(function(d){return d.wt.getDate()==8});
			}
			else if (day == 2){
				data = timeDict[t].filter(function(d){return d.pt.getDate()==15});
				weatherData = weatherDict[u].filter(function(d){return d.wt.getDate()==15});
			}
			else if (day == 3){
				data = timeDict[t].filter(function(d){return d.pt.getDate()==18});
				weatherData = weatherDict[u].filter(function(d){return d.wt.getDate()==18});
			}
			


			timeText=svg.select("#dateAndTime1").data(data).text(function(d){
				var days = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];
				return days[d.pt.getDay()] + ", ";
			});

			timeText=svg.select("#dateAndTime2").data(data).text(function(d){
				var days = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];
				return "June " + d.pt.getDate() + "th, 2016";
			});

			timeText=svg.select("#dateAndTime3").data(data).text(function(d){
				var days = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];
				var hour; var minutes; var timeHalf="am"
				if (d.pt.getHours()==0){
					hour=12;
				}
				else if(d.pt.getHours() > 11){
					timeHalf="pm";

					if (d.pt.getHours() > 12){
						hour = d.pt.getHours() - 12;
					} else {
						hour=12;
					}
				} else{
					hour = d.pt.getHours();
				}

				if (d.pt.getMinutes()<10){
					minutes="0"+d.pt.getMinutes();
				}else{
					minutes=d.pt.getMinutes();
				}
				return hour + ":" + minutes + timeHalf;
			});


			timeImage=svg.select("weatherImage").data(weatherData).attr("xlink:href", function(d){
				if ((d.cond == "Rain") || (d.cond == "Heavy Rain") || (d.cond == "Light Rain")){
					return "rain.svg";
				}
				else if ((d.cond == "Clear")){
					return "clear.svg";
				}
				else {
					return "cloudy.svg";
				}
			});


			var pickDots = svg.selectAll(".pickups").data(data);
			pickDots.exit().remove();
			pickDots.enter().append("circle").attr("class", "pickups").attr("r", 3).style("fill", "red")
			.attr("cx", function(d) { 
				if ((d.dropLat > 1.895121486*d.dropLong+180.9002959) && (d.dropLat > .0550037105*d.dropLong+44.77000868) && (d.dropLat < 1.547301526*d.dropLong+155.2683443) && (d.dropLat < -76.50437318*d.dropLong-5615.435765) && (d.pickLat > 1.895121486*d.pickLong+180.9002959) && (d.pickLat > .0550037105*d.pickLong+44.77000868) &&  (d.pickLat < -76.50437318*d.pickLong-5615.435765) && (d.pickLat < 1.547301526*d.pickLong+155.2683443)){
					return projection([d.pickLong,d.pickLat])[0];
				}
			})
			.attr("cy", function(d) { 
				if ((d.dropLat > 1.895121486*d.dropLong+180.9002959) && (d.dropLat > .0550037105*d.dropLong+44.77000868) && (d.dropLat < 1.547301526*d.dropLong+155.2683443) &&  (d.dropLat < -76.50437318*d.dropLong-5615.435765) && (d.pickLat > 1.895121486*d.pickLong+180.9002959) && (d.pickLat > .0550037105*d.pickLong+44.77000868) && (d.pickLat < -76.50437318*d.pickLong-5615.435765) && (d.pickLat < 1.547301526*d.pickLong+155.2683443)){
					return projection([d.pickLong,d.pickLat])[1];
				}
			})
			.on("mouseover", function(d){return tooltip.style("visibility", "visible").text("Time: " + d.pickTime + "\nTrip Distance: " + d.dist +"\nFare: " + d.fare);})
			.on("mousemove", function(){return tooltip.style("top", (event.pageY-10)+"px").style("left", (event.pageX+10)+"px");})
			.on("mouseout", function(){return tooltip.style("visibility", "hidden");})
			.attr("transform", "translate(-200,200) rotate(-27)");
		}


		
		plotLineGraph("#p", 1,2,2,2 );
		


	  });

	function closest(num, arr){
    	var curr = 0
    	for (i=0;i<arr.length;i++){
    	    if (Math.abs(num - arr[i]) < Math.abs(num - arr[curr])){
    	        curr = i;
    	    }
    	}
    	return arr[curr];
    }



	function plotLineGraph(id, data, yfield, ylabel, title){
		var timeExtent = [];
		var yExtent = [];

		var length = 800;
		var svg =  d3.select(id).append("svg")
			.attr("width", length)
			.attr("height", length);
		var padding = length/10;

		var x = d3.scaleTime()
    		.domain(timeExtent).range([padding, length-padding]);
    	var y = d3.scaleLinear()
    		.domain(yExtent).range([length-padding, padding]);

    	var xAxis = d3.axisBottom(x);
		var yAxis = d3.axisLeft(y);

		var plot = svg.append("g").attr("transform", "translate(0,0)");
		plot.append("g").call(xAxis).attr("transform", "translate(0," + (length-padding).toString()+ ")");
		plot.append("g").call(yAxis).attr("transform", "translate(" + padding.toString() +",0)");
		// var pathGenerator = d3.line()
		// 	.x(function (d) { return x(d.Date); })
		// 	.y(function (d) { return y(d.yfield); });

		// var paths = plot.selectAll("path.lineGraph").data(data);
		// paths.enter().append("path")
		// 	.merge(paths)
		// 	// .on("mouseover", function(d){ 
		// 	// 	svg.select("#SectorName").text(d.key);
		// 	// })
		// 	.attr("class", "lineGraph")
		// 	.transition().duration(1000)
		// 	.attr("d", function(sector){ 
		// 		return pathGenerator(sector.values);
		// 	})

		// 	.style("stroke", function(sector, i){ 
		// 		return "blue";
		// 	})

		// Append Titles and Axis Labels
		svg.append("text")
			.text("Histogram")
			.attr("x", length/2)
			.attr("y", 15)
			.attr("text-anchor", "middle")
			.attr("font-family", "Palatino")
			.attr("font-size", 14)
			.attr("fill", "black");

		svg.append("text")
			.text("Fr.")
			.attr("x", 5)
			.attr("y", length/2)
			.attr("text-anchor", "start")
			.attr("font-family", "Palatino")
			.attr("font-size", 12)
			.attr("fill", "black");
		
		svg.append("text")
			.text("Value")
			.attr("x", length/2)
			.attr("y", length-10)
			.attr("text-anchor", "end")
			.attr("font-family", "Palatino")
			.attr("font-size", 12)
			.attr("fill", "black");


	}

	//Returns the checked radio button
	function getCheckedButton (chkboxName) {
	  var checkboxes = document.getElementsByClassName(chkboxName);
	  var checkboxesChecked = [];
	  // loop over them all
	  for (var i=0; i<checkboxes.length; i++) {
	     // And stick the checked ones onto an array...
	     if (checkboxes[i].checked) {
	        var val = d3.select(checkboxes[i]).attr("value");
	        checkboxesChecked.push(parseInt(val));
	     }
	  }
	  if (checkboxesChecked.length == 1 && checkboxesChecked[0] == '50'){
	  	checkboxesChecked = [];
	  	for (var i = 0; i < 50; i++) {
	  		checkboxesChecked.push(i);
	  	}
	  	//console.log(checkboxesChecked);
	  }
	  // Return the array if it is non-empty, or null
	  return checkboxesChecked.length > 0 ? checkboxesChecked : null;
	}


      
    </script>
  </body>
</html>