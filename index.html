<!DOCTYPE html>

<head>
    <meta charset="utf-8">
    <title></title>
</head>

<body>
    <p id="p">
        <label for="time">Time</label>
        <input style="width: 300px;" type="range" id="time" min="0" value="0" max="1440" step="1">
    </p>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="http://d3js.org/topojson.v2.min.js"></script>
    <script src="https://d3js.org/d3-geo.v1.min.js"></script>
    <script src="https://d3js.org/d3-geo-projection.v1.min.js"></script>
    <script>
        var timeDict = {};
        var inspectionArray = [];
        var taxiArray = [];

        var parseInspect = function(row) {
            longitude = parseFloat(row.Longitude);
            latitude = parseFloat(row.Latitude);
            businessName = row.Business_Name;
            inspectionResult = row.Inspection_Result;
            industry = row.Industry;

            inspectionArray.push({
                longitude: longitude,
                latitude: latitude,
                businessName: businessName,
                inspectionResult: inspectionResult,
                industry: industry
            });
        };

        var parseTaxi = function(row) {

            dropLong = parseFloat(row.dropoff_longitude);
            dropLat = parseFloat(row.dropoff_latitude);
            dropTime = row.dropoff_datetime;
            pickLong = parseFloat(row.pickup_longitude);
            pickLat = parseFloat(row.pickup_latitude);
            fare = parseFloat(row.payment_amount);

            var obj = {
                dropLong: dropLong,
                dropLat: dropLat,
                dropTime: dropTime,
                pickLong: pickLong,
                pickLat: pickLat,
                fare: fare
            };
			
            var time = obj.dropTime.split(' ')[1];
            var slots = time.split(':');
            var tot = parseInt(slots[0]) * 60 + parseInt(slots[1]);
            if (!(tot in timeDict)) {
                timeDict[tot] = [obj];
            } else {
                timeDict[tot].push(obj);
            }
			
            taxiArray.push(obj);
        };


        d3.queue()
            .defer(d3.csv, "ManhattanInspect.txt", parseInspect)
            .defer(d3.csv, "June1Taxi.txt", parseTaxi)
            .defer(d3.json, "nyc.json")
            .await(function(error, inspect, taxi, nyc) {
                console.log("Code in the call-back function is only executed when every data file loads.");

                // inspectionArray.sort(function(a,b){
                //   if(a.latitude < b.latitude){return -1;}
                //   else{return 1;}
                // });
                //

                var svg = d3.select("#p").append("svg").attr("height", 1100).attr("width", 500);

                var projection = d3.geoMercator().center([-73.94, 40.70])
                    .scale(200000);

                projection.fitExtent([
                    [0, 0],
                    [svg.attr("width"), svg.attr("height")]
                ], nyc);

                var pathGenerator = d3.geoPath().projection(projection);
                var p = svg.append("g");

                p.selectAll(".state")
                    .data(nyc.features)
                    .enter().append("path")
                    .attr("d", pathGenerator)
                    .attr("transform", "translate(-200,200) rotate(-27)")
                    .attr("fill", "grey");
					
					// for (var j = 0; j < taxiArray.length; j++){
	// 					console.log(taxiToInspect(taxiArray[j],200));
	// 				}

                var slide = d3.select("#time");
                slide.on("input", function() {
                    t = this.value;
                    var dots = svg.selectAll("circle").data(timeDict[t]);
                    dots.exit().remove();
                    dots.enter().append("circle").attr("r", 4).style("fill", "blue")
                        .attr("cx", function(d) {
                            return projection([d.dropLong, d.dropLat])[0];
                        })
                        .attr("cy", function(d) {
                            return projection([d.dropLong, d.dropLat])[1];
                        })
                        .attr("transform", "translate(-200,200) rotate(-27)")
                        .on("click", function(d) {
                            console.log(ins);
                        });
                });
            });

        function distance(lat1, long1, lat2, long2) { //returns distance in feet
            latDiff = lat1 - lat2;
            latDiff = latDiff * 364320 //364320=69 miles in feet, 1 degree of Lat is about 69 miles
            longDiff = long1 - long2;
            longDiff = longDiff * 279840 //279840=53 miles in feet, 1 degree of long is about 53 miles at 40 degrees north

            return Math.sqrt(Math.pow(latDiff, 2) + Math.pow(longDiff, 2));
        }

        function taxiToInspect(taxi, maxDist) { //returns closest business from inspectionArray to a taxi dropoff, or -1 if above max dist
            dropLat = taxi.dropLat;
            dropLong = taxi.dropLong;

            closestIndex=-1;
            dist=1000000000;

            for(i=0;i<inspectionArray.length;i++){
                   //console.log("dist= "+dist);
                   //console.log(distance(taxi.dropLat, taxi.dropLong, inspectionArray[i].latitude, inspectionArray[i].longitude));
            	   var val = distance(taxi.dropLat, taxi.dropLong, inspectionArray[i].latitude, inspectionArray[i].longitude);
                   if(val<dist){
                     closestIndex=i;
                     dist=val;
                   }
                 }

            if (dist <= maxDist) {
                return inspectionArray[closestIndex];
            } else {
                return -1;
            }
        }
    </script>
</body>

</html>